Got it — you’re on the BYOB (Bring Your Own Browser) path now, which is the right free route. From your logs, your server is fine, but the extension → backend bridge isn’t delivering any payloads, so your UI keeps polling /api/results/1 and never sees rows.

Below is a plug-and-play checklist + the exact things to add to main.py (only Python stays in main.py as you wanted) and the minimal extension pieces you need so that opening Skyscanner/Kayak/airline pages in your own browser actually pushes real flight data back and you see it populate live.

1) Why you’re seeing “no results”
No ingestion calls are hitting the server (your logs only show GET /api/results/1 loops). That means:

The extension isn’t installed/active, or

The extension is posting to the wrong URL (e.g., http://0.0.0.0:5000 or http://localhost:5000 from your Chromebook, which points to your Chromebook, not Codespaces), or

CORS/permissions block the extension’s fetch, or

The extension doesn’t know which query_id to attach to the scraped results, so it skips sending.

Fix those four and you’ll see rows instantly.

2) One-time networking fix (critical)
Use the exact public URL you see in your browser’s address bar for your app (Codespaces gives you an HTTPS *.githubpreview.dev URL). That is your BACKEND_BASE_URL.

Don’t use 0.0.0.0, 127.0.0.1, or the raw VM IP in your extension.

In the extension Options, set BACKEND_BASE_URL = https://<your-codespace-preview-host>/.

In main.py, allow that origin via CORS.

3) Add these endpoints & CORS to main.py
Paste these as-is (adjust only if names collide). They give the extension a health check, a config endpoint, an ingestion endpoint, and a debug sample. Keep all in main.py.

# --- BEGIN: BYOB bridge (add to main.py) -------------------------------------
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
import time, uuid, re, json

# 1) CORS: allow your Codespaces preview origin
# If you already created app = FastAPI(), just extend the middleware.
ALLOWED_ORIGINS = ["*"]  # while developing; later lock to your preview domain
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 2) Models (stable schema for ingestion)
class Fare(BaseModel):
    brand: Optional[str] = None            # Economy Basic / Light / Plus
    cabin: Optional[str] = None            # economy/premium/business
    baggage: Optional[str] = None          # e.g., "cabin only", "1x23kg"
    refundable: Optional[bool] = None
    change_penalty: Optional[str] = None

class Leg(BaseModel):
    carrier: str                           # "BA"
    flight_number: str                     # "BA432"
    origin: str                            # "LHR"
    destination: str                       # "AMS"
    depart_iso: str                        # "2025-08-27T07:45:00+01:00"
    arrive_iso: str                        # "2025-08-27T10:05:00+02:00"
    aircraft: Optional[str] = None         # "A320"
    duration_min: Optional[int] = None

class Itinerary(BaseModel):
    provider: str                          # "skyscanner" | "kayak" | "ba" | ...
    url: str
    deep_link: Optional[str] = None
    price: float
    currency: str = "GBP"
    legs: List[Leg]
    fare: Optional[Fare] = None
    extra: Optional[Dict[str, Any]] = None

    @validator("currency")
    def _upcase(cls, v): return v.upper()

class IngestPayload(BaseModel):
    query_id: int
    source_domain: str
    page_title: Optional[str] = None
    user_agent: Optional[str] = None
    results: List[Itinerary]

# 3) Health endpoints for the extension
@app.get("/api/ping")
async def ping():
    return {"ok": True, "ts": time.time()}

@app.get("/api/sdk/hello")
async def sdk_hello():
    return {
        "ok": True,
        "ts": time.time(),
        "schema": "v1",
        "ingest_endpoint": "/api/ingest",
    }

# 4) Simple in-memory pub for results (works with your existing SQLite code too)
SSE_CHANNELS: Dict[int, List[Dict[str, Any]]] = {}

def _normalize_key(itin: Itinerary) -> str:
    # For dedupe: BA432|2025-08-27T07:45|LHR|AMS|GBP|123.45 (plus legs length)
    first = itin.legs[0]
    last  = itin.legs[-1]
    return "|".join([
        first.carrier+first.flight_number,
        first.depart_iso,
        first.origin,
        last.destination,
        itin.currency,
        f"{itin.price:.2f}",
        str(len(itin.legs)),
    ])

# 5) This is where the extension POSTs real flights
@app.post("/api/ingest")
async def ingest(payload: IngestPayload, request: Request):
    # Validate query exists — if you have a DB, check it; here we trust dev-mode.
    qid = payload.query_id
    dedup: Dict[str, Itinerary] = {}
    for r in payload.results:
        try:
            k = _normalize_key(r)
            if k not in dedup:
                dedup[k] = r
            else:
                # keep cheaper
                if r.price < dedup[k].price:
                    dedup[k] = r
        except Exception:
            continue

    clean = list(dedup.values())
    # Persist to DB if you already created tables; otherwise stash in memory
    SSE_CHANNELS.setdefault(qid, []).extend([r.dict() for r in clean])

    # If your /api/results/{qid} reads from SQLite, also write them there now.
    # Example (pseudocode):
    # with db() as conn:
    #    for r in clean:
    #        upsert_itinerary(conn, qid, r)  # create unique index on dedupe key

    return {"ok": True, "ingested": len(clean)}

# 6) Optional: SSE stream for live updates (UI can switch from polling)
@app.get("/api/stream/{query_id}")
async def stream(query_id: int):
    async def gen():
        last_sent = 0
        while True:
            bucket = SSE_CHANNELS.get(query_id, [])
            if len(bucket) > last_sent:
                for i in range(last_sent, len(bucket)):
                    yield f"data: {json.dumps(bucket[i])}\n\n"
                last_sent = len(bucket)
            await asyncio.sleep(1.0)
    return StreamingResponse(gen(), media_type="text/event-stream")

# 7) Debug route to prove UI wiring works even without the extension
@app.post("/api/debug/ingest_example/{query_id}")
async def debug_ingest_example(query_id: int):
    sample = IngestPayload(
        query_id=query_id,
        source_domain="example",
        results=[
            Itinerary(
                provider="example",
                url="https://example.com/flights/LHR-AMS",
                deep_link="https://example.com/book/abc123",
                price=96.0,
                currency="GBP",
                legs=[Leg(
                    carrier="BA", flight_number="432",
                    origin="LHR", destination="AMS",
                    depart_iso="2025-08-27T07:45:00+01:00",
                    arrive_iso="2025-08-27T10:05:00+02:00",
                    aircraft="A320", duration_min=80
                )],
                fare=Fare(brand="Economy Basic", cabin="ECONOMY", baggage="cabin only"),
                extra={"notes": "debug sample"}
            )
        ]
    )
    SSE_CHANNELS.setdefault(query_id, []).append(sample.results[0].dict())
    return {"ok": True, "ingested": 1}
# --- END: BYOB bridge --------------------------------------------------------
Quick test without the extension:

curl -X POST https://<your-preview>/api/debug/ingest_example/1
Refresh your results table — you should see one BA itinerary. If you do, the UI side is wired; now hook the extension.

4) The minimal extension you need (free, MV3, Chrome 103 OK)
manifest.json

{
  "manifest_version": 3,
  "name": "FlightAlert BYOB Bridge",
  "version": "0.1.0",
  "description": "Extracts live fares from airline/OTA pages and posts to your backend.",
  "permissions": ["storage", "scripting", "activeTab"],
  "host_permissions": [
    "https://*.skyscanner.net/*",
    "https://*.kayak.com/*",
    "https://*.google.com/travel/flights/*",
    "https://*.britishairways.com/*",
    "https://*/*"
  ],
  "action": { "default_popup": "popup.html" },
  "options_page": "options.html",
  "background": { "service_worker": "background.js" },
  "content_scripts": [
    {
      "matches": [
        "https://*.skyscanner.net/*",
        "https://*.kayak.com/*",
        "https://*.google.com/travel/flights/*",
        "https://*.britishairways.com/*"
      ],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ],
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; connect-src *"
  }
}
options.html (lets you set the backend URL and current query id)

<!doctype html><meta charset="utf-8"/>
<h3>FlightAlert BYOB Settings</h3>
<label>Backend base URL <input id="base" placeholder="https://your-preview.githubpreview.dev"/></label><br/>
<label>Current Query ID <input id="qid" type="number" min="1"/></label><br/>
<button id="save">Save</button>
<script>
  (async () => {
    const s = await chrome.storage.sync.get(["BACKEND_BASE_URL","QUERY_ID"]);
    document.getElementById('base').value = s.BACKEND_BASE_URL || "";
    document.getElementById('qid').value  = s.QUERY_ID || "";
  })();
  document.getElementById('save').onclick = async () => {
    const BACKEND_BASE_URL = document.getElementById('base').value.trim().replace(/\/+$/,'');
    const QUERY_ID = parseInt(document.getElementById('qid').value,10) || null;
    await chrome.storage.sync.set({ BACKEND_BASE_URL, QUERY_ID });
    alert("Saved");
  };
</script>
popup.html (quick diagnostics)

<!doctype html><meta charset="utf-8"/>
<div id="out"></div>
<button id="ping">Ping</button>
<script>
  document.getElementById('ping').onclick = async () => {
    const {BACKEND_BASE_URL} = await chrome.storage.sync.get("BACKEND_BASE_URL");
    const r = await fetch(`${BACKEND_BASE_URL}/api/ping`);
    document.getElementById('out').textContent = await r.text();
  };
</script>
background.js (receives results from content scripts and posts to your backend)

async function postResults(payload) {
  const { BACKEND_BASE_URL } = await chrome.storage.sync.get("BACKEND_BASE_URL");
  if (!BACKEND_BASE_URL) { console.warn("BYOB: BACKEND_BASE_URL not set"); return; }
  try {
    const r = await fetch(`${BACKEND_BASE_URL}/api/ingest`, {
      method: "POST", headers: { "content-type": "application/json" },
      body: JSON.stringify(payload)
    });
    const j = await r.json();
    console.log("BYOB: ingest ok", j);
  } catch (e) {
    console.error("BYOB: ingest failed", e);
  }
}

// Listen for messages from content scripts
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if (msg && msg.type === "BYOB_RESULTS") postResults(msg.payload);
});
content.js (extractor skeleton with domain adapters + robust fallbacks)

(function () {
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const nowIso = ()=>new Date().toISOString();

  // A tiny registry: add many adapters over time (100s of sites possible)
  const adapters = {
    "www.kayak.com": extractKayak,
    "www.skyscanner.net": extractSkyscanner,
    "www.britishairways.com": extractBA,
    "www.google.com": extractGflights
  };

  async function getQueryId() {
    const s = await chrome.storage.sync.get("QUERY_ID");
    return s.QUERY_ID || null;
  }

  async function send(results) {
    const qid = await getQueryId();
    if (!qid) { console.warn("BYOB: no QUERY_ID set"); return; }
    const payload = {
      query_id: qid,
      source_domain: location.hostname,
      page_title: document.title,
      user_agent: navigator.userAgent,
      results
    };
    chrome.runtime.sendMessage({ type: "BYOB_RESULTS", payload });
  }

  // === Adapters ===
  async function extractKayak() {
    // 1) Wait for app to load
    for (let i=0;i<20;i++) {
      if (document.querySelector('[data-test-id="result-card"]')) break;
      await sleep(500);
    }
    // 2) Try embedded JSON first (most robust)
    let results = [];
    [...document.querySelectorAll('script[type="application/json"]')].forEach(s=>{
      try {
        const j = JSON.parse(s.textContent || "{}");
        // Heuristic: find objects that look like priced itineraries
        const flights = JSON.stringify(j).match(/"price"\s*:\s*{[^}]*}|"legs"\s*:\s*\[/) ? j : null;
        if (flights) results.push(...normalizeFromUnknownJson(j, "kayak"));
      } catch {}
    });
    // 3) Fallback to DOM scraping (selectors evolve; this is only a starter)
    if (!results.length) {
      const cards = document.querySelectorAll('[data-test-id="result-card"]');
      cards.forEach((card)=>{
        const priceEl = card.querySelector('[data-test-id="price-text"]');
        const priceTxt = priceEl ? priceEl.textContent.trim() : null;
        const price = priceTxt ? parseFloat(priceTxt.replace(/[^\d.]/g,'')) : null;
        const legs = []; // fill via DOM parsing if available
        if (price && legs.length) {
          results.push({
            provider: "kayak",
            url: location.href,
            price, currency: "GBP",
            legs,
            fare: { brand: null, cabin: "ECONOMY" }
          });
        }
      });
    }
    return results;
  }

  async function extractSkyscanner() {
    // Skyscanner often uses JSON blobs; wait for app shell
    for (let i=0;i<20;i++) {
      if (document.querySelector('script[type="application/json"]')) break;
      await sleep(500);
    }
    let results = [];
    [...document.querySelectorAll('script[type="application/json"]')].forEach(s=>{
      try { results.push(...normalizeFromUnknownJson(JSON.parse(s.textContent||"{}"), "skyscanner")); } catch {}
    });
    return results;
  }

  async function extractBA() {
    // Airline pages vary heavily; start with visible fare cards.
    let results = [];
    for (let i=0;i<30;i++) {
      if (document.querySelector('[class*="fare"]')) break;
      await sleep(500);
    }
    const cards = document.querySelectorAll('[class*="fare"],[data-test*="fare"]');
    cards.forEach((c)=>{
      const priceTxt = c.textContent.match(/£\s?\d[\d,.]*/i)?.[0] || null;
      const price = priceTxt ? parseFloat(priceTxt.replace(/[^\d.]/g,'')) : null;
      // Minimal single-leg normalization as placeholder
      const legs = detectLegsFromPage() || [];
      if (price && legs.length) results.push({
        provider: "ba", url: location.href, price, currency: "GBP",
        legs, fare: { brand: "Economy", cabin: "ECONOMY" }
      });
    });
    return results;
  }

  async function extractGflights() {
    // Google Flights renders in shadow DOM; JSON is accessible via script tags/URL state.
    let results = [];
    [...document.querySelectorAll('script[type="application/ld+json"],script[type="application/json"]')].forEach(s=>{
      try { results.push(...normalizeFromUnknownJson(JSON.parse(s.textContent||"{}"), "googleflights")); } catch {}
    });
    return results;
  }

  // === Normalizers (very tolerant, looks for patterns rather than fixed keys) ===
  function normalizeFromUnknownJson(obj, provider) {
    const out = [];
    const text = JSON.stringify(obj);
    // Pull prices
    const priceMatches = [...text.matchAll(/"price"\s*:\s*"?([0-9]+(?:\.[0-9]+)?)"?/g)];
    // Pull currency (fallback GBP)
    const curr = (text.match(/"currency"\s*:\s*"([A-Z]{3})"/)?.[1]) || "GBP";
    // Very generic single-leg detector via IATA codes in URL/title (you will improve this)
    const legs = detectLegsFromPage() || [];
    priceMatches.slice(0, 30).forEach(m=>{
      const price = parseFloat(m[1]);
      if (!isFinite(price)) return;
      if (!legs.length) return;
      out.push({
        provider, url: location.href,
        price, currency: curr, legs,
        fare: { cabin: "ECONOMY" }
      });
    });
    return out;
  }

  function detectLegsFromPage() {
    // Heuristic from URL like /flights/LHR-AMS/2025-08-27
    const u = location.href;
    const m = u.match(/([A-Z]{3})[-/](?:[A-Z]{3})[-/](?:[A-Z]{3})|([A-Z]{3})[-/]([A-Z]{3})/);
    let o=null,d=null;
    if (m) {
      if (m[2] && m[3]) { o=m[2]; d=m[3]; }
      else if (m[1]) { const parts=m[1].split('-'); o=parts[0]; d=parts[1]; }
    }
    if (!o || !d) return null;
    // Time windows are hard; try to read visible times
    const timeEls = [...document.querySelectorAll('*')].filter(e => /\d{1,2}:\d{2}/.test(e.textContent||"")).slice(0,2);
    const dep = timeEls[0]?.textContent?.trim();
    const arr = timeEls[1]?.textContent?.trim();
    const depIso = dep ? guessTodayIso(dep) : new Date().toISOString();
    const arrIso = arr ? guessTodayIso(arr) : new Date(Date.now()+2*3600e3).toISOString();
    // Airline code
    const flightTxt = document.body.textContent.match(/\b([A-Z]{2})\s?(\d{2,4})\b/);
    const carrier = flightTxt ? flightTxt[1] : "XX";
    const number  = flightTxt ? flightTxt[2] : "0000";
    return [{
      carrier, flight_number: number,
      origin: o, destination: d,
      depart_iso: depIso, arrive_iso: arrIso,
      aircraft: null, duration_min: null
    }];
  }

  function guessTodayIso(hhmm) {
    const [h,m] = hhmm.split(':').map(x=>parseInt(x,10));
    const d = new Date();
    d.setHours(h); d.setMinutes(m); d.setSeconds(0); d.setMilliseconds(0);
    return d.toISOString();
  }

  // ==== Boot ====
  (async function run(){
    const host = location.hostname;
    const adapter = adapters[host] || null;
    if (!adapter) return; // do nothing on unrelated sites
    try {
      // wait a little for SPA hydration to calm down
      await sleep(1500);
      const results = await adapter();
      if (results && results.length) {
        await send(results);
        console.log("BYOB: sent", results.length, "itineraries");
      } else {
        console.log("BYOB: no results extracted (yet)");
        // Keep watching for late-rendered content
        const obs = new MutationObserver(async ()=> {
          const MORE = await adapter();
          if (MORE && MORE.length) { obs.disconnect(); await send(MORE); }
        });
        obs.observe(document.documentElement, {childList:true,subtree:true});
      }
    } catch(e) {
      console.error("BYOB: extractor failed", e);
    }
  })();
})();
This is intentionally generic but resilient: it prefers embedded JSON first (highest success across sites), then falls back to DOM. It also runs a MutationObserver so if the site renders slowly or after interaction, you’ll still capture.

5) Pass the active query_id to the extension (no manual typing)
Add this tiny broadcast to your search page (the HTML served by your FastAPI UI). Right after the server returns { id: 1, ... } from /api/query, do:

<script>
  // when the search is created and you have queryId
  function onQueryCreated(queryId) {
    // save locally (so your page can poll /api/results/{id})
    window.localStorage.setItem("FA_QUERY_ID", String(queryId));
    // broadcast to the extension to auto-populate options
    window.postMessage({ type: "FA_QUERY_CREATED", queryId }, "*");
  }

  // Let the content script capture it and write to chrome.storage
</script>
And in content.js (add near the top):

window.addEventListener("message", async (ev) => {
  if (!ev?.data || ev.data.type !== "FA_QUERY_CREATED") return;
  const q = parseInt(ev.data.queryId, 10);
  if (!q) return;
  await chrome.storage.sync.set({ QUERY_ID: q });
  console.log("BYOB: QUERY_ID updated via postMessage:", q);
});
Now, when you press “Search” in your app, the extension learns the query_id automatically.

6) Make the success rate high (≥70%) — what to add next
Prefer JSON over pixels
Nearly all OTAs/metas embed big JSON blobs:

<script type="application/json">...</script>

<script type="application/ld+json">...</script>

Globals like window.__INITIAL_STATE__, window.__KAYAK_INITIAL_STATE
Extend normalizeFromUnknownJson to traverse objects and pick:

price (total), currency

each leg’s marketingCarrier, flightNumber, departureAirportCode, arrivalAirportCode, departureDateTime, arrivalDateTime, aircraft, durationMinutes

fare brand (Basic/Light/Plus), baggage & restrictions
Add site-specific JSON mappers: normalizeKayak(json), normalizeSkyscanner(json), normalizeBA(json) that call the generic normalizer.

URL heuristics → robust matching
Ingest payload should self-classify (origin/dest/date) from URL and validate against your query (±2 days window), otherwise discard. That prevents pollution from unrelated tabs.

Debounce & dedupe in the extension
Keep a small in-memory map keyed by [carrier+number|depISO|orig|dest|currency]. Only send new/cheaper items; throttle posts to at most 1 per 2–3 seconds.

Resilience against CAPTCHA/late render
The user solves the CAPTCHA when present; your MutationObserver continues and fires once content appears. That’s why BYOB succeeds where server-side scraping fails.

Confidence scoring
In content.js, set extra.confidence = 0..1 (e.g., JSON-sourced = 0.95, DOM-sourced = 0.7). In main.py store and sort by confidence for display.

Flight number authority check (free)
Flight numbers are often visible as text; cross-check BA\d+|U2\d+|KL\d+. Drop items without a plausible flight code or with mismatched carrier vs domain (e.g., BA on ryanair.com).

Currency normalization
Always parse currency from JSON if available; else infer from locale or DOM symbols. Store price in minor units(e.g., pence) in DB for stable dedupe/comparison.

Persist & upsert
In main.py add a unique index on the dedupe key and do upsert on ingest to keep only the cheapest/latest record per itinerary.

Errors you can surface to the user
Add /api/ingest/errors ring buffer so the dashboard can show: “No data received — fix extension BASE_URL or grant host permissions”.

7) Step-by-step “make it work right now” guide
Load the extension

Visit chrome://extensions, toggle Developer mode, Load unpacked → select the extension folder with the four files above.

Open the extension Options, set:

Backend base URL = your exact Codespaces preview URL (HTTPS).

Current Query ID leave blank for now (we’ll broadcast it).

Open your app (the same preview URL), create a search

Your UI calls /api/query and receives id (e.g., 1).

Your page runs window.postMessage({type:"FA_QUERY_CREATED", queryId: 1}).

Check the extension’s service worker console (click “service worker” under your extension in chrome://extensions) — you should see a log like “QUERY_ID updated…”.

Open a supported site tab (Skyscanner/Kayak/BA) with the matching route/date

Wait for the fare list to render (or interact once if needed).

Open the background console again: you should see “BYOB: sent N itineraries”.

Your FastAPI logs should show POST /api/ingest 200.

Verify in UI

Your results table for that query id should fill immediately.

If not, run:

fetch('/api/ping').then(r=>r.json()).then(console.log)
from the browser devtools on your app tab — if OK, the network path is fine; re-check BASE_URL inside the extension options.

8) Chromebook constraints (Chrome OS 103)
MV3 is supported.

Do not rely on very new APIs (e.g., offscreen documents). You’re only using storage, scripting, activeTab, fetch — all good.

Keep the extension light; avoid huge libraries.

9) Production-grade polish (still free)
CSP already set to allow connect-src * for extension pages so fetch to your backend works even over HTTPS.

CORS on FastAPI lets your preview origin in. Lock it down later.

SSE endpoint is included — switch your UI from polling to event stream for snappier updates.

Auth (optional, free): generate a random X-FA-Token in main.py, store it in chrome.storage.sync, require it in /api/ingest headers.

Adapters at scale: keep adding site adapters (100s possible). Always start with JSON parsing, then DOM fallback, then MutationObserver.

TL;DR (do these 5 and you’ll see data)
Set the extension BACKEND_BASE_URL to your Codespaces HTTPS preview URL.

Add the CORS + /api/ping + /api/sdk/hello + /api/ingest code to main.py.

Broadcast the query_id from your app page via window.postMessage, and write it to chrome.storage.sync in content.js.

Load the extension (dev mode), open Kayak/Skyscanner/BA result pages, wait for results; watch background console for “ingest ok”.

Confirm your UI table populates for that query_id. If not, hit /api/debug/ingest_example/{id} to confirm the UI path, then fix the extension BASE_URL or host permissions.

Do this and you’ll have real prices + real flights (e.g., “British Airways BA432 LHR→AMS £96”) flowing, at high success because you’re extracting directly from the pages the user loads — no proxies, no paid APIs, and robust against most anti-bot measures

